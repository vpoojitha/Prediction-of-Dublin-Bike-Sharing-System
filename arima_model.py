# -*- coding: utf-8 -*-
"""ARIMA_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ufkzvZM68Jkal3V2angLbV8RVwg9bRDy

**ARIMA MODEL**
"""

# Commented out IPython magic to ensure Python compatibility.
#Importing Libraries
from numpy import concatenate
from matplotlib import pyplot
from pandas import read_csv
from pandas import DataFrame
from pandas import concat
from sklearn.metrics import mean_squared_error
from math import sqrt
import numpy as np
import pandas as pd
import matplotlib.pylab as plt
# %matplotlib inline
from matplotlib.pylab import rcParams
rcParams['figure.figsize']=10,6
import datetime as dt
import os
import seaborn as sns
from pandas import datetime
!pip install statsmodels 
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.tsa.arima_model import ARIMA
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
import itertools 
import warnings

#Reading the csv file consisting of weather and bike data with stations encoded
def parser(x):
	return datetime.strptime(x,'%Y-%m-%d %H:%M:%S')
 
data = read_csv('Final_dataset.csv', header=0, parse_dates=[1], index_col=1, squeeze=True, date_parser=parser)
print(data.head())
#series.plot()
#pyplot.show()

#processing of dataframe for the model
data = data.loc[:, ~series.columns.str.contains('^Unnamed')]
data.head()
#Considering station 0 for forecasting of the availability
df=data.loc[(series['Stations']==0),:]
#Dropping the station column 
df=df.drop('Stations',1)
#finding the difference (d=1) value of parameter for ARIMA
df_diff=df.diff(periods=1)
df_diff=df_diff[1:]

#plotting ACF for non stationary data frame
plot_acf(df)

#plotting ACF for stationary data frame by shifting by 1 unit.
plot_acf(df_diff)

X=df.values
X.size

train=X[0:3000]
test=X[3000:]
predictions= []

"""**ARIMA model**"""

#Checking for stationarity of the data frame by ADA statistics
result = adfuller(df_diff['availability'])
print('ADF Statistic: {}'.format(result[0]))
print('p-value: {}'.format(result[1]))
print('Critical Values:')
for key, value in result[4].items():
    print('\t{}: {}'.format(key, value))

#Checking for stationarity of the data frame by rolling mean and standard deviation of non staionary data frame.
roll_mean = df.rolling(window = 20).mean()
roll_std = df.rolling(window = 20).std()
plt.plot(df, color = 'blue', label = 'Original')
plt.plot(roll_mean, color = 'red', label = 'Rolling Mean')
plt.plot(roll_std, color = 'black', label = 'Rolling Std')
plt.legend(loc = 'best')
plt.title('Rolling Mean & Rolling Standard Deviation')
plt.show()

#Checking for stationarity of the data frame by rolling mean and standard deviation of staionary data frame.
df_log = np.log(df)
roll_mean = df_log.rolling(window=12).mean()
df_log_minus_mean = df_log - roll_mean
df_log_minus_mean.dropna(inplace=True)
get_stationarity(df_log_minus_mean)

#finding best p,q,d values through least AIC values
p=d=q=range(0,5)
pdq=list(itertools.product(p,d,q))
warnings.filterwarnings('ignore')
for param in pdq:
  try:
    model_arima=ARIMA(train,order=param)
    model_arima_fit=model_arima.fit()
    print(param, model_arima_fit.aic)
  except:
    continue

#ARIMA Model
X = df.values
size = int(len(X) * 0.70)
train, test = X[0:size], X[size:len(X)]
history = [x for x in train]
predictions = list()
for t in range(len(test)):
	model = ARIMA(history, order=(3,1,3))
	model_fit = model.fit(disp=0)
	output = model_fit.forecast()
	yhat = output[0]
	predictions.append(yhat)
	obs = test[t]
	history.append(obs)
	print('predicted=%f, expected=%f' % (yhat, obs))
error = mean_squared_error(test, predictions)
print('Test MSE: %.3f' % error)
# plot
pyplot.plot(test)
pyplot.plot(predictions, color='orange')
pyplot.show()